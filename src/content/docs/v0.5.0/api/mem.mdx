{/* This file was auto-generated with "zune-docs" */}

# Byte/Buffer Manipulation
`zune.mem`

---
import { Callout, Tabs } from 'nextra/components'

A library to manipulate/interact with bytes and buffers.

## Properties
### MAX_SIZE
The maximum amount of bytes luau can hold.
```luau tooltips
MAX_SIZE: number
```
## Functions
### len
Gets the length of a slice.
This is similar to `buffer.len` but this supports strings and FFI pointers as well.
```luau tooltips
-- @hover: (10,26)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
len(src: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to get the length of.
</details>

### copy
Copies data from one slice to another.
This is similar to `buffer.copy` but this supports strings and FFI pointers as well.
```luau tooltips
-- @hover: (12,28)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemWritableSlice = buffer | FFIPointer]
-- @hover: (55,71)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
copy(dest: MemWritableSlice, destOffset: number, src: MemReadableSlice, srcOffset: number, count: number?): ()
```
<details open>
<summary>Parameters</summary>
- `dest: MemWritableSlice{:luau}` - The destination to copy to.
- `destOffset: number{:luau}` - The offset to start copying to in the destination.
- `src: MemReadableSlice{:luau}` - The source to copy from.
- `srcOffset: number{:luau}` - The offset to start copying from in the source.
- `count: number?{:luau}` - The number of bytes to copy. If not provided, will copy until the end of the source.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### slice
Slices a portion of a source and returns it as a new buffer.

This does allocate memory for the new buffer.
```luau tooltips
-- @hover: (12,28)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
slice(src: MemReadableSlice, offset: number, count: number?): buffer
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to slice from.
- `offset: number{:luau}` - The offset to start the slice from.
- `count: number?{:luau}` - The number of bytes to include in the slice. If not provided,
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### eqlSlice
Compares two slices for equality.
```luau tooltips
-- @hover: (51,67)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (13,29)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
eqlSlice(a: MemReadableSlice, aOffset: number, b: MemReadableSlice, bOffset: number, count: number?): boolean
```
<details open>
<summary>Parameters</summary>
- `a: MemReadableSlice{:luau}` - The first slice to compare.
- `aOffset: number{:luau}` - The offset to start the comparison from in the first slice.
- `b: MemReadableSlice{:luau}` - The second slice to compare.
- `bOffset: number{:luau}` - The offset to start the comparison from in the second slice.
- `count: number?{:luau}` - The number of bytes to compare.
</details>

### eql
Compares two slices for equality.
A shortcut for `eqlSlice(a, 0, b, 0, nil)`.
```luau tooltips
-- @hover: (8,24)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (29,45)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
eql(a: MemReadableSlice, b: MemReadableSlice): boolean
```
<details open>
<summary>Parameters</summary>
- `a: MemReadableSlice{:luau}` - The first slice to compare.
- `b: MemReadableSlice{:luau}` - The second slice to compare.
</details>

### startsWith
Checks if a slice starts with a given needle.
```luau tooltips
-- @hover: (45,61)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (19,35)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
startsWith(slice: MemReadableSlice, needle: MemReadableSlice): boolean
```
<details open>
<summary>Parameters</summary>
- `slice: MemReadableSlice{:luau}` - The slice to check.
- `needle: MemReadableSlice{:luau}` - The needle to check for.
</details>

### endsWith
Checks if a slice ends with a given needle.
```luau tooltips
-- @hover: (43,59)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (17,33)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
endsWith(slice: MemReadableSlice, needle: MemReadableSlice): boolean
```
<details open>
<summary>Parameters</summary>
- `slice: MemReadableSlice{:luau}` - The slice to check.
- `needle: MemReadableSlice{:luau}` - The needle to check for.
</details>

### trim
Trims the given values from both ends of the buffer.
```luau tooltips
-- @hover: (11,27)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (46,62)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
trim(src: MemReadableSlice, values_to_strip: MemReadableSlice): buffer
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to trim.
- `values_to_strip: MemReadableSlice{:luau}` - The values to trim from the source.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### trimLeft
Trims the given values from the left end of the buffer.
```luau tooltips
-- @hover: (50,66)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (15,31)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
trimLeft(src: MemReadableSlice, values_to_strip: MemReadableSlice): buffer
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to trim.
- `values_to_strip: MemReadableSlice{:luau}` - The values to trim from the source.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### trimRight
Trims the given values from the right end of the buffer.
```luau tooltips
-- @hover: (51,67)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (16,32)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
trimRight(src: MemReadableSlice, values_to_strip: MemReadableSlice): buffer
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to trim.
- `values_to_strip: MemReadableSlice{:luau}` - The values to trim from the source.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### find
Find the index of a needle in the buffer.
```luau tooltips
-- @hover: (11,27)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (37,53)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
find(src: MemReadableSlice, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `needle: MemReadableSlice{:luau}` - The needle to search for.
</details>

### findPos
Find the index of a needle in the buffer, starting from the given offset.
```luau tooltips
-- @hover: (14,30)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (56,72)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findPos(src: MemReadableSlice, offset: number, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number{:luau}` - The offset to start searching from.
- `needle: MemReadableSlice{:luau}` - The needle to search for.
</details>

### findLast
Find the last index of a needle in the buffer.
```luau tooltips
-- @hover: (41,57)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (15,31)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findLast(src: MemReadableSlice, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `needle: MemReadableSlice{:luau}` - The needle to search for.
</details>

### findScalar
Find the index of a scalar/char in the buffer.
```luau tooltips
-- @hover: (17,33)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findScalar(src: MemReadableSlice, char: number): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `char: number{:luau}` - The byte to search for.
</details>

### findScalarPos
Find the index of a scalar/char in the buffer, starting from the given offset.
```luau tooltips
-- @hover: (20,36)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findScalarPos(src: MemReadableSlice, offset: number, char: number): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number{:luau}` - The offset to start searching from.
- `char: number{:luau}` - The byte to search for.
</details>

### findScalarLast
Find the last index of a scalar/char in the buffer.
```luau tooltips
-- @hover: (21,37)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findScalarLast(src: MemReadableSlice, char: number): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `char: number{:luau}` - The byte to search for.
</details>

### findAny
Find the index of the first byte that is in the given `needle`.
```luau tooltips
-- @hover: (40,56)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (14,30)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findAny(src: MemReadableSlice, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `needle: MemReadableSlice{:luau}` - The bytes to search for.
</details>

### findAnyPos
Find the index of the first byte that is in the given `needle`, starting from the given `offset`.
```luau tooltips
-- @hover: (59,75)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (17,33)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findAnyPos(src: MemReadableSlice, offset: number, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number{:luau}` - The offset to start searching from.
- `needle: MemReadableSlice{:luau}` - The bytes to search for.
</details>

### findAnyLast
Find the last index of a byte that is in the given `needle`.
```luau tooltips
-- @hover: (18,34)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (44,60)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findAnyLast(src: MemReadableSlice, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `needle: MemReadableSlice{:luau}` - The bytes to search for.
</details>

### findNone
Find the index of the first byte that is not in the given `needle`.
```luau tooltips
-- @hover: (41,57)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (15,31)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findNone(src: MemReadableSlice, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `needle: MemReadableSlice{:luau}` - The bytes to not search for.
</details>

### findNonePos
Find the index of the first byte that is not in the given `needle`, starting from the given `offset`.
```luau tooltips
-- @hover: (60,76)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (18,34)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findNonePos(src: MemReadableSlice, offset: number, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number{:luau}` - The offset to start searching from.
- `needle: MemReadableSlice{:luau}` - The bytes to not search for.
</details>

### findNoneLast
Find the last index of a byte that is not in the given `needle`.
```luau tooltips
-- @hover: (45,61)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (19,35)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findNoneLast(src: MemReadableSlice, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `needle: MemReadableSlice{:luau}` - The bytes to not search for.
</details>

### findDiff
Find the index of the first difference between two buffers.
```luau tooltips
-- @hover: (41,57)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (15,31)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findDiff(src: MemReadableSlice, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `needle: MemReadableSlice{:luau}`
</details>

### findDiffPos
Find the index of the first difference between two buffers, starting from the given offset.
```luau tooltips
-- @hover: (60,76)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (18,34)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findDiffPos(src: MemReadableSlice, offset: number, needle: MemReadableSlice): number?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number{:luau}` - The offset to start searching from.
- `needle: MemReadableSlice{:luau}`
</details>

### findMax
Find the index of the maximum value in the buffer.

Expects the buffer to be non-empty.
```luau tooltips
-- @hover: (14,30)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findMax(src: MemReadableSlice, offset: number?, count: number?): number
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number?{:luau}` - The offset to start searching from.
- `count: number?{:luau}` - The number of bytes to search. If not provided, will search until the end of the buffer.
</details>

### findMin
Find the index of the minimum value in the buffer.

Expects the buffer to be non-empty.
```luau tooltips
-- @hover: (14,30)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findMin(src: MemReadableSlice, offset: number?, count: number?): number
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number?{:luau}` - The offset to start searching from.
- `count: number?{:luau}` - The number of bytes to search. If not provided, will search until the end of the buffer.
</details>

### findMinMax
Find both the index of the minimum and maximum values in the buffer.

Expects the buffer to be non-empty.
```luau tooltips
-- @hover: (17,33)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
findMinMax(src: MemReadableSlice, offset: number?, count: number?): (number, number)
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number?{:luau}` - The offset to start searching from.
- `count: number?{:luau}` - The number of bytes to search. If not provided, will search until the end of the buffer.
</details>

### cutPrefix
Cuts the buffer only if it starts with the given prefix. Returning the rest of the buffer.
```luau tooltips
-- @hover: (42,58)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (16,32)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
cutPrefix(src: MemReadableSlice, prefix: MemReadableSlice): buffer?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to cut from.
- `prefix: MemReadableSlice{:luau}` - The prefix to check for.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### cutSuffix
Cuts the buffer only if it ends with the given suffix. Returning the rest of the buffer.
```luau tooltips
-- @hover: (42,58)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (16,32)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
cutSuffix(src: MemReadableSlice, suffix: MemReadableSlice): buffer?
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to cut from.
- `suffix: MemReadableSlice{:luau}` - The suffix to check for.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### cut
Cuts the buffer at the first occurrence of the needle, returning the part before and after the needle.
If the needle is not found, returns nil.
```luau tooltips
-- @hover: (10,26)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (36,52)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
cut(src: MemReadableSlice, needle: MemReadableSlice): (buffer?, buffer?)
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to cut from.
- `needle: MemReadableSlice{:luau}` - The needle to cut at.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### cutLast
Cuts the buffer at the last occurrence of the needle, returning the part before and after the needle.
If the needle is not found, returns nil.
```luau tooltips
-- @hover: (40,56)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
-- @hover: (14,30)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
cutLast(src: MemReadableSlice, needle: MemReadableSlice): (buffer?, buffer?)
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to cut from.
- `needle: MemReadableSlice{:luau}` - The needle to cut at.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### cutScalar
Cuts the buffer at the first occurrence of the scalar/char, returning the part before and after the char.
If the char is not found, returns nil.
```luau tooltips
-- @hover: (16,32)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
cutScalar(src: MemReadableSlice, char: number): (buffer?, buffer?)
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to cut from.
- `char: number{:luau}` - The byte to cut at.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### cutScalarLast
Cuts the buffer at the last occurrence of the scalar/char, returning the part before and after the char.
If the char is not found, returns nil.
```luau tooltips
-- @hover: (20,36)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
cutScalarLast(src: MemReadableSlice, char: number): (buffer?, buffer?)
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to cut from.
- `char: number{:luau}` - The byte to cut at.
</details>
<details>
<summary>Throws</summary>
- Memory Error
</details>

### replaceScalar
Replaces all occurrences of a scalar in the buffer with another scalar.
- `[1, 2, 3, 2]` with (`2`, `4`) -> `[1, 4, 3, 4]`
```luau tooltips
-- @hover: (20,36)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemWritableSlice = buffer | FFIPointer]
replaceScalar(src: MemWritableSlice, char: number, replacement: number, offset: number?, count: number?): ()
```
<details open>
<summary>Parameters</summary>
- `src: MemWritableSlice{:luau}` - The source to replace in.
- `char: number{:luau}` - The byte to replace.
- `replacement: number{:luau}` - The byte to replace with.
- `offset: number?{:luau}` - The offset to start replacing from.
- `count: number?{:luau}` - The number of bytes to replace. If not provided, will replace until the end of the buffer.
</details>

### max
Finds the maximum value in the buffer.

Expects the buffer to be non-empty.
```luau tooltips
-- @hover: (10,26)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
max(src: MemReadableSlice, offset: number?, count: number?): number
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number?{:luau}` - The offset to start searching from.
- `count: number?{:luau}` - The number of bytes to search. If not provided, will search until the end of the buffer.
</details>

### min
Finds the minimum value in the buffer.

Expects the buffer to be non-empty.
```luau tooltips
-- @hover: (10,26)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
min(src: MemReadableSlice, offset: number?, count: number?): number
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to search in.
- `offset: number?{:luau}` - The offset to start searching from.
- `count: number?{:luau}` - The number of bytes to search. If not provided, will search until
</details>

### reverse
Reverses the buffer in place.
- `[1, 2, 3]` -> `[3, 2, 1]`
```luau tooltips
-- @hover: (14,30)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemWritableSlice = buffer | FFIPointer]
reverse(src: MemWritableSlice, offset: number?, count: number?): ()
```
<details open>
<summary>Parameters</summary>
- `src: MemWritableSlice{:luau}` - The source to reverse in.
- `offset: number?{:luau}` - The offset to start reversing from.
- `count: number?{:luau}` - The number of bytes to reverse. If not provided, will reverse until
</details>

### rotate
Rotates the buffer to the left by the given amount.

For example, rotating `[1, 2, 3, 4, 5]` by `2` would result in `[3, 4, 5, 1, 2]`.
```luau tooltips
-- @hover: (13,29)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemWritableSlice = buffer | FFIPointer]
rotate(src: MemWritableSlice, amount: number, offset: number?, count: number?): ()
```
<details open>
<summary>Parameters</summary>
- `src: MemWritableSlice{:luau}` - The source to rotate in.
- `amount: number{:luau}` - The amount to rotate by.
- `offset: number?{:luau}` - The offset to start rotating from.
- `count: number?{:luau}` - The number of bytes to rotate. If not provided, will rotate up to the end of the buffer.
</details>

### set
Sets the value of the buffer at the given offset to the given value, for the given count of bytes.
```luau tooltips
-- @hover: (11,27)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemWritableSlice = buffer | FFIPointer]
set(dest: MemWritableSlice, value: number, offset: number?, count: number?): ()
```
<details open>
<summary>Parameters</summary>
- `dest: MemWritableSlice{:luau}` - The source to write in.
- `value: number{:luau}` - The value to set.
- `offset: number?{:luau}` - The offset to start writing at.
  - default: `0{:luau}`
- `count: number?{:luau}` - The number of bytes to write. If not provided, will write until the end of the buffer.
</details>

### toVector2
Reads a vector with only 2 elements from a buffer.
```luau tooltips
-- @hover: (16,32)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
toVector2(src: MemReadableSlice, offset: number?): vector
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to read from.
- `offset: number?{:luau}` - The offset to start reading from.
</details>

### toVector3
Reads a vector with only 3 elements from a buffer.
```luau tooltips
-- @hover: (16,32)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemReadableSlice = string | buffer | FFIPointer]
toVector3(src: MemReadableSlice, offset: number?): vector
```
<details open>
<summary>Parameters</summary>
- `src: MemReadableSlice{:luau}` - The source to read from.
- `offset: number?{:luau}` - The offset to start reading from.
</details>

### writeVector2
Writes a vector with only 2 elements to a buffer.
```luau tooltips
-- @hover: (20,36)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemWritableSlice = buffer | FFIPointer]
writeVector2(dest: MemWritableSlice, offset: number?, vec: vector): ()
```
<details open>
<summary>Parameters</summary>
- `dest: MemWritableSlice{:luau}` - The destination to write to.
- `offset: number?{:luau}` - The offset to start writing to.
- `vec: vector{:luau}` - The vector to write.
</details>

### writeVector3
Writes a vector with only 3 elements to a buffer.
```luau tooltips
-- @hover: (20,36)[-- references:
-- @link: (8,18)[../objects/FFIPointer]
-- (1) FFIPointer

export type MemWritableSlice = buffer | FFIPointer]
writeVector3(dest: MemWritableSlice, offset: number?, vec: vector): ()
```
<details open>
<summary>Parameters</summary>
- `dest: MemWritableSlice{:luau}` - The destination to write to.
- `offset: number?{:luau}` - The offset to start writing to.
- `vec: vector{:luau}` - The vector to write.
</details>
